from typing import List, Tuple, Dict, Optional, Sequence
"""
Export helpers for tagged XYZ and CP2K KIND sections.
"""


import numpy as np
from collections import Counter

def export_xyz_with_labels(filename: str, labels: Sequence[str], positions: Sequence[Sequence[float]], comment: str = "Generated by charge_transfer") -> None:
    n = len(labels)
    lines = [str(n), comment]
    for lab, pos in zip(labels, positions):
        lines.append(f"{lab:<8s} {pos[0]:.6f} {pos[1]:.6f} {pos[2]:.6f}")
    with open(filename, "w") as f:
        f.write("\n".join(lines) + "\n")
    print(f"[export] Wrote tagged XYZ: {filename}")

def tag_by_coordination(symbols: Sequence[str], G, global_field: Optional[Sequence[Dict[str, float]]] = None, base_out: Optional[str] = None):
    labeled = []
    breakdown = Counter()
    mag_by_label = {}
    mags = {e['atom_index']: e['magnitude'] for e in (global_field or [])}
    for i, el in enumerate(symbols):
        deg = int(G.degree[i])
        lab = f"{el}{deg}"
        labeled.append(lab)
        breakdown[lab] += 1
        if i in mags:
            mag_by_label.setdefault(lab, []).append(mags[i])
    stats = _write_breakdown(base_out, "coordination", breakdown, mag_by_label)
    return labeled, stats

def tag_by_environment(symbols: Sequence[str], G, global_field: Optional[Sequence[Dict[str, float]]] = None, base_out: Optional[str] = None):
    labeled = []
    breakdown = Counter()
    mag_by_label = {}
    mags = {e['atom_index']: e['magnitude'] for e in (global_field or [])}
    for i, central in enumerate(symbols):
        neigh = list(G.neighbors(i))
        elems = [symbols[j] for j in neigh]
        cnt = Counter(elems)
        parts = [f"{cnt[e]}{e}" for e in sorted(cnt)]
        lab = f"{central}{''.join(parts)}"
        labeled.append(lab)
        breakdown[lab] += 1
        if i in mags:
            mag_by_label.setdefault(lab, []).append(mags[i])
    stats = _write_breakdown(base_out, "environment", breakdown, mag_by_label)
    return labeled, stats

def tag_by_magnitude(symbols: Sequence[str], global_field: Sequence[Dict[str, float]], ranges: Optional[Sequence[str]], base_out: Optional[str] = None):
    labeled = list(symbols)
    breakdown = Counter()
    mag_by_label = {}
    bins = []
    for r in (ranges or []):
        try:
            name, lo, hi = r.split(':')
            bins.append((name, float(lo), float(hi)))
        except Exception:
            print(f"[warn] Ignoring malformed --tag-magnitude item: '{r}' (expected name:min:max)")
    mags = {e['atom_index']: e['magnitude'] for e in (global_field or [])}
    for i, el in enumerate(symbols):
        m = mags.get(i, None)
        if m is None:
            continue
        for (name, lo, hi) in bins:
            if lo <= m < hi:
                lab = f"{el}_{name}"
                labeled[i] = lab
                breakdown[lab] += 1
                mag_by_label.setdefault(lab, []).append(m)
                break
    stats = _write_breakdown(base_out, "magnitude", breakdown, mag_by_label)
    return labeled, stats

def _write_breakdown(base_out: Optional[str], kind: str, breakdown: 'Counter', mag_by_label: Dict[str, list]) -> Dict[str, Dict[str, float]]:
    stats = {}
    if base_out:
        path = f"{base_out}_{kind}_breakdown.txt"
        with open(path, "w") as f:
            f.write(f"{kind.capitalize():<28} {'Count':>8} {'Mean|flow|':>14} {'Std':>10}\n")
            for lab in sorted(breakdown):
                cnt = breakdown[lab]
                values = np.asarray(mag_by_label.get(lab, []), float)
                mean = float(np.nanmean(values)) if values.size else 0.0
                std  = float(np.nanstd(values)) if values.size else 0.0
                f.write(f"{lab:<28} {cnt:>8} {mean:>14.4f} {std:>10.4f}\n")
                stats[lab] = {"count": cnt, "mean": mean, "std": std}
        print(f"[export] Breakdown table -> {path}")
    return stats

# CP2K KIND sections for labels
_KIND_PARAMS = {
    "In": ("DZVP-MOLOPT-SR-GTH-q13", "GTH-PBE-q13"),
    "As": ("DZVP-MOLOPT-SR-GTH-q5",  "GTH-PBE-q5"),
    "Cl": ("DZVP-MOLOPT-SR-GTH-q7",  "GTH-PBE-q7"),
    "Cs": ("DZVP-MOLOPT-SR-GTH-q9",  "GTH-PBE-q9"),
    "Pb": ("DZVP-MOLOPT-SR-GTH-q4",  "GTH-PBE-q4"),
    "Br": ("DZVP-MOLOPT-SR-GTH-q7",  "GTH-PBE-q7"),
    "Se": ("DZVP-MOLOPT-SR-GTH-q6",  "GTH-PBE-q6"),
    "Sb": ("DZVP-MOLOPT-SR-GTH-q5",  "GTH-PBE-q5"),
    "Ga": ("DZVP-MOLOPT-SR-GTH-q13", "GTH-PBE-q13"),
    "Zn": ("DZVP-MOLOPT-SR-GTH-q12", "GTH-PBE-q12"),
    "Cd": ("DZVP-MOLOPT-SR-GTH-q12", "GTH-PBE-q12"),
    "Hf": ("DZVP-MOLOPT-SR-GTH-q12", "GTH-PBE-q12"),
    "Te": ("DZVP-MOLOPT-SR-GTH-q6",  "GTH-PBE-q6"),
    "P":  ("DZVP-MOLOPT-SR-GTH-q5",  "GTH-PBE-q5"),
    "S":  ("DZVP-MOLOPT-SR-GTH-q6",  "GTH-PBE-q6"),
    "H":  ("DZVP-MOLOPT-SR-GTH-q1",  "GTH-PBE-q1"),
    "C":  ("DZVP-MOLOPT-SR-GTH-q4",  "GTH-PBE-q4"),
    "O":  ("DZVP-MOLOPT-SR-GTH-q6",  "GTH-PBE-q6"),
}

def _detect_element_from_label(label: str) -> Optional[str]:
    known = sorted(_KIND_PARAMS.keys(), key=len, reverse=True)
    for el in known:
        if label.startswith(el):
            return el
    return None

def kind_sections_from_labels(labels: Sequence[str]) -> str:
    uniq = sorted(set(labels))
    lines = []
    for lab in uniq:
        el = _detect_element_from_label(lab)
        if el is None:
            basis, pot = "DZVP-MOLOPT-SR-GTH-qX", "GTH-PBE-qX"
            el_name = "Xx"
        else:
            basis, pot = _KIND_PARAMS[el]
            el_name = el
        lines.append(f"&KIND {lab}\n"
                     f"  ELEMENT {el_name}\n"
                     f"  BASIS_SET {basis}\n"
                     f"  POTENTIAL {pot}\n"
                     f"&END KIND\n\n")
    return "".join(lines)

def write_kind_sections_for_xyz(labels: Sequence[str], exported_xyz_path: str) -> Tuple[str, str]:
    txt = kind_sections_from_labels(labels)
    kinds_path = exported_xyz_path.replace(".xyz", "_kinds.txt")
    with open(kinds_path, "w") as f:
        f.write(txt)
    print(f"[export] KIND sections written to: {kinds_path}")
    return kinds_path, txt